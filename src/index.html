<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: monospace; display: flex; flex-direction: column; height: 100vh; }
        .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; height: 80vh; gap: 2px; background: #222; }
        .panel { background: #000; position: relative; overflow: hidden; border: 1px solid #444; }
        .label { position: absolute; top: 2px; left: 2px; font-size: 8px; color: #0f0; z-index: 10; background: #000; padding: 2px; }
        #controls { height: 20vh; background: #111; padding: 10px; border-top: 1px solid #0f0; display: flex; flex-direction: column; gap: 10px; box-sizing: border-box; }
        .row { display: flex; align-items: center; gap: 10px; width: 100%; }
        .btn { flex: 1; background: #222; color: #0f0; border: 1px solid #0f0; padding: 8px; cursor: pointer; font-size: 10px; font-weight: bold; }
        #status { font-size: 9px; color: #f0f; text-align: center; }
    </style>
</head>
<body>
    <div class="grid">
        <div class="panel" id="p1"><span class="label">SIM-1: COLLECTIVE_STEERING</span></div>
        <div class="panel" id="p2"><span class="label">SIM-2: PROBABILITY_FIELD</span></div>
        <div class="panel" id="p3"><span class="label">SIM-3: 3D_ENGINE</span></div>
    </div>
    <div id="controls">
        <div class="row">
            <strong>AUTONOMY:</strong> <input type="range" id="warp" min="1" max="500" value="150">
        </div>
        <div class="row">
            <button class="btn" id="saveBtn">ðŸ’¾ LOG SEARCH</button>
            <button class="btn" id="stackBtn">ðŸ“¡ SYNC & STEER</button>
        </div>
        <div id="status">NEURAL_STEERING_OFFLINE</div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "supabase": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { createClient } from 'supabase';

        const sb = createClient('https://xoolmbmnzbsvcqeyqvyi.supabase.co', 'sb_publishable_A1cLFAKbAg77TfTkD2RB-w_PahU316T');
        const status = document.getElementById('status');
        const warpSlider = document.getElementById('warp');
        let trail = [];
        let collectivePoints = [];

        function setup(id, is3D) {
            const el = document.getElementById(id);
            const scene = new THREE.Scene();
            const cam = is3D ? new THREE.PerspectiveCamera(75, el.clientWidth/el.clientHeight, 0.1, 100) : new THREE.OrthographicCamera(-2.5,2.5,2.5,-2.5,0.1,100);
            const ren = new THREE.WebGLRenderer({ antialias: true });
            ren.setSize(el.clientWidth, el.clientHeight);
            el.appendChild(ren.domElement);
            cam.position.z = 5;
            return { scene, cam, ren };
        }

        const s1 = setup('p1', false); const s2 = setup('p2', false); const s3 = setup('p3', true);
        const liveL = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xff00ff }));
        s1.scene.add(liveL);
        const stackGroup = new THREE.Group();
        s2.scene.add(stackGroup);

        const ball = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0x00ff00}));
        s3.scene.add(ball);
        s3.scene.add(new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(4,4,4)), 0x00ff00));

        let pos = new THREE.Vector3(0,0,0);
        let vel = new THREE.Vector3(0.041, 0.033, 0.021);

        document.getElementById('saveBtn').onclick = async () => {
            status.innerText = "UPLOADING...";
            await sb.from('jobs').insert([{
                status: 'completed', variant_name: 'sim3colts',
                config: { entropy: warpSlider.value },
                result: { log: trail.map(p=>({x:p.x, y:p.y})), type: 'billiard_map' }
            }]);
            status.innerText = "COORDINATION LOGGED";
        };

        document.getElementById('stackBtn').onclick = async () => {
            status.innerText = "SYNCING STEERING FIELD...";
            const { data } = await sb.from('jobs').select('result').eq('variant_name', 'sim3colts').order('created_at', { ascending: false }).limit(10);
            while(stackGroup.children.length > 0){ stackGroup.remove(stackGroup.children[0]); }
            collectivePoints = [];
            if (data) {
                data.forEach((run, i) => {
                    const pts = run.result.log.map(p => new THREE.Vector3(p.x, p.y, 0));
                    collectivePoints.push(...pts);
                    const geo = new THREE.BufferGeometry().setFromPoints(pts);
                    const mat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.1 + (i * 0.05) });
                    stackGroup.add(new THREE.Line(geo, mat));
                });
                status.innerText = "STEERING_ACTIVE: 10 NODES";
            }
        };

        function loop() {
            let e = warpSlider.value / 1000;
            let dist = 2 - Math.max(Math.abs(pos.x), Math.abs(pos.y));
            let cur = e / (dist + 0.05);
            
            // --- STEERING LOGIC ---
            // If we have collective data, the bot "avoids" the most crowded points
            if (collectivePoints.length > 0) {
                let repulsion = new THREE.Vector3(0,0,0);
                // Sample a few collective points to see if we're too close
                for(let i=0; i<10; i++) {
                    let cp = collectivePoints[Math.floor(Math.random() * collectivePoints.length)];
                    let d = pos.distanceTo(cp);
                    if (d < 0.5) {
                        let diff = pos.clone().sub(cp).normalize().multiplyScalar(0.001 / (d + 0.1));
                        repulsion.add(diff);
                    }
                }
                vel.add(repulsion);
            }

            vel.x += Math.sin(pos.y * cur) * 0.01;
            vel.y += Math.cos(pos.x * cur) * 0.01;
            pos.add(vel);

            if (Math.abs(pos.x) > 2) { vel.x *= -1; pos.x = Math.sign(pos.x) * 1.99; }
            if (Math.abs(pos.y) > 2) { vel.y *= -1; pos.y = Math.sign(pos.y) * 1.99; }
            
            ball.position.copy(pos);
            trail.push(pos.clone()); if (trail.length > 1000) trail.shift();
            liveL.geometry.setFromPoints(trail.map(p => new THREE.Vector3(p.x, p.y, 0)));
            s1.ren.render(s1.scene, s1.cam); s2.ren.render(s2.scene, s2.cam); s3.ren.render(s3.scene, s3.cam);
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>
</html>
